#include "ccc/project.h"
#include <filesystem>
#include <string>
#include <unordered_set>
#include <vector>

using namespace std;
using namespace ccc;
namespace fs = filesystem;

void copy_directory(const fs::path& source, const fs::path& destination);

void ccc_init(project* self, string cmd, vector<string> args) {
    // Set compiler flags
    unordered_set<string> ccc_args(args.begin(), args.end());
    if (ccc_args.find("release") != ccc_args.end()) {
        self->add_compile_flags(
            {"-O2", "-std=c++17", "-W", "-Wall", "-Wextra"});
    } else {
        self->add_compile_flags(
            {"-Og", "-g", "-std=c++17", "-W", "-Wall", "-Wextra"});
    }

    /* Describe the executable program ccc. */
    execution ccc(
        "ccc",
        "The ccc does not rely on cccmain and cccproject, but its working "
        "principle is to link project.cpp, cccmain, and cccproject in a "
        "directory with project.cpp to generate and call project, and call "
        "defautl_project in a directory without project.cpp.");
    ccc.obj_path = "./ccc/build/obj";
    ccc.output_path = "./build/bin";
    ccc.add_source_files({"./ccc/src/ccc.cpp"});
    ccc.add_header_folder_paths({"./cccproject/inc", "./ccc/inc"});
    self->add_task(&ccc);

    /* Describe the library file cccmain. */
    library cccmain(
        "cccmain", static_library,
        "The cccmain relies on cccproject and defines the built-in commands of "
        "ccc using the interfaces provided in cccproject.");
    cccmain.obj_path = "./cccmain/build/obj";
    cccmain.output_path = "./build/lib";
    cccmain.add_source_files({"./cccmain/src/cccmain.cpp"});
    cccmain.add_header_folder_paths({"./cccproject/inc"});
    self->add_task(&cccmain);

    /* Describe the library file cccproject. */
    library cccproject("cccproject", static_library,
                       "The ccc project is the main component of the project, "
                       "defining how to describe the project when using ccc.");
    cccproject.obj_path = "./cccproject/build/obj";
    cccproject.output_path = "./build/lib";
    cccproject.add_source_files({"./cccproject/src/ccc"}, {".cpp"});
    cccproject.add_header_folder_paths({"./cccproject/inc"});
    self->add_task(&cccproject);

    /* Describe the executable program default_project. */
    execution default_project(
        "default_project",
        "This program is generated by linking cccmain and cccpoject, and does "
        "not include project.cpp. When there is no project.cpp in the "
        "directory where ccc is executed, the program will be called by ccc.");
    default_project.output_path = "./build/bin";
    default_project.add_dependency(&cccmain, true);
    default_project.add_dependency(&cccproject, true);
    self->add_task(&default_project);

    // Copy the cccproject/inc directory to the build/inc directory when running
    // the build command.
    if (cmd == "build" && fs::exists("./cccproject/inc") &&
        fs::is_directory("./cccproject/inc")) {
        copy_directory("./cccproject/inc", "./build/inc");
    }

    // Clean the build/inc directory when running the clean command.
    if (cmd == "clean") {
        fs::remove_all("./build/inc");
    }
}

void ccc_exit(project* self, string cmd, vector<string> args) {}

project ccc_project("CCC", ccc_init, ccc_exit, "");

void copy_directory(const fs::path& source, const fs::path& destination) {
    try {
        // Check if the source path exists and is a directory
        if (!fs::exists(source) || !fs::is_directory(source)) {
            cerr << "Source directory does not exist or is not a directory."
                 << endl;
            return;
        }

        // Create target directory
        if (!fs::exists(destination)) {
            fs::create_directories(destination);
        }

        // Traverse all entries in the source directory
        for (const auto& entry : fs::directory_iterator(source)) {
            const auto& path = entry.path();
            const auto& filename = path.filename();
            const auto dest_path = destination / filename;

            if (fs::is_directory(path)) {
                // If it is a directory, recursively copy
                copy_directory(path, dest_path);
            } else if (fs::is_regular_file(path)) {
                // If it is a file, remove the existing file and copy the file
                if (fs::exists(dest_path)) {
                    fs::remove(dest_path);
                }
                fs::copy_file(path, dest_path,
                              fs::copy_options::overwrite_existing);
            }
        }
    } catch (const fs::filesystem_error& e) {
        cerr << "Filesystem error: " << e.what() << endl;
    } catch (const exception& e) {
        cerr << "General error: " << e.what() << endl;
    }
}

#ifdef _WIN32
void debug(vector<string> args) {
    cout << "Compile the ccc in debug mode." << endl;
    system("ccc build debug");
}
#endif
#ifdef __linux__
void debug(vector<string> args) {
    cout << "Compile the ccc in debug mode." << endl;
    system("bash -c 'ccc build debug'");
}
#endif
command debug_cmd("debug", debug, "Compile the ccc in debug mode.");

#ifdef _WIN32
void release(vector<string> args) {
    cout << "Compile the ccc in release mode." << endl;
    system("ccc build release");
}
#endif
#ifdef __linux__
void release(vector<string> args) {
    cout << "Compile the ccc in release mode." << endl;
    system("bash -c 'ccc build release'");
}
#endif
command release_cmd("release", release, "Compile the ccc in release mode.");